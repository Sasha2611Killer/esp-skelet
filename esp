local ESP = {}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Settings
local ESP_SETTINGS = {
	MasterSwitch = false,
	Components = {
		Skeleton = {
			Enabled = false,
			Color = Color3.new(1, 0, 0),
			Thickness = 2,
			TeamCheck = false,
			VisibleOnly = false,
			HeadCircle = {
				Enabled = true,
				BaseSize = 1.5,
				MinSize = 0.3,
				Thickness = 2,
				DynamicSize = true
			}
		},
		Name = {
			Enabled = false,
			Color = Color3.new(1, 1, 1),
			ShowDistance = true,
			Size = 14,
			Outline = true,
			OutlineColor = Color3.new(0, 0, 0),
			Offset = Vector2.new(0, -30)
		},
		Box = {
			Enabled = false,
			Color = Color3.new(1, 1, 1),
			Thickness = 1,
			TeamCheck = false,
			VisibleOnly = false,
			FillTransparency = 1
		}
	}
}

-- Cache
local LocalPlayer = Players.LocalPlayer
local Skeletons = {}
local DrawingCache = {
	Lines = {},
	Circles = {},
	Texts = {},
	Quads = {}
}

-- Constants
local R15_JOINTS = {
	Head = "Head",
	UpperTorso = "UpperTorso",
	LowerTorso = "LowerTorso",
	LeftUpperArm = "LeftUpperArm",
	LeftLowerArm = "LeftLowerArm",
	LeftHand = "LeftHand",
	RightUpperArm = "RightUpperArm",
	RightLowerArm = "RightLowerArm",
	RightHand = "RightHand",
	LeftUpperLeg = "LeftUpperLeg",
	LeftLowerLeg = "LeftLowerLeg",
	RightUpperLeg = "RightUpperLeg",
	RightLowerLeg = "RightLowerLeg"
}

local R15_CONNECTIONS = {
	{"Head", "UpperTorso"},
	{"UpperTorso", "LowerTorso"},
	{"UpperTorso", "LeftUpperArm"},
	{"LeftUpperArm", "LeftLowerArm"},
	{"LeftLowerArm", "LeftHand"},
	{"UpperTorso", "RightUpperArm"},
	{"RightUpperArm", "RightLowerArm"},
	{"RightLowerArm", "RightHand"},
	{"LowerTorso", "LeftUpperLeg"},
	{"LeftUpperLeg", "LeftLowerLeg"},
	{"LowerTorso", "RightUpperLeg"},
	{"RightUpperLeg", "RightLowerLeg"}
}

local R6_JOINTS = {
	Head = "Head",
	Torso = "Torso",
	LeftArm = "Left Arm",
	RightArm = "Right Arm",
	LeftLeg = "Left Leg",
	RightLeg = "Right Leg"
}

local R6_CONNECTIONS = {
	{"Head", "Torso"},
	{"Torso", "LeftArm"},
	{"Torso", "RightArm"},
	{"Torso", "LeftLeg"},
	{"Torso", "RightLeg"}
}

-- Utility functions
local function CreateDrawingObject(type, properties)
	local drawing = Drawing.new(type)
	for prop, value in pairs(properties) do
		drawing[prop] = value
	end
	return drawing
end

local function GetCachedDrawing(type, key, skeleton, properties)
	properties = properties or {}
	properties.Visible = false
	properties.ZIndex = 10

	if not skeleton[key] then
		skeleton[key] = CreateDrawingObject(type, properties)
		DrawingCache[type.."s"][skeleton[key]] = true
	end
	return skeleton[key]
end

local function RemoveSkeleton(skeleton)
	if not skeleton then return end

	for _, drawing in pairs(skeleton) do
		if drawing and drawing.Remove then
			DrawingCache[drawing.ClassName][drawing] = nil
			drawing:Remove()
		end
	end
end

local function ClearComponent(skeleton, pattern)
	for key, drawing in pairs(skeleton) do
		if string.find(key, pattern) then
			if drawing and drawing.Remove then
				drawing:Remove()
			end
			skeleton[key] = nil
		end
	end
end

local function IsPartVisible(part, character)
	if not part then return false end
	local cameraPos = Camera.CFrame.Position
	local ray = Ray.new(cameraPos, (part.Position - cameraPos).Unit * 1000)
	local hit = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})
	return hit == nil or hit:IsDescendantOf(character)
end

local function GetPlayerColor(plr, component)
	local settings = ESP_SETTINGS.Components[component]
	if settings.TeamCheck and plr.Team then
		return plr.TeamColor.Color
	end
	return settings.Color
end

-- Update functions
local function UpdateSkeleton(plr, skeleton)
	if not ESP_SETTINGS.MasterSwitch then
		for _, drawing in pairs(skeleton) do
			if drawing then drawing.Visible = false end
		end
		return
	end

	local character = plr.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		for _, drawing in pairs(skeleton) do
			if drawing then drawing.Visible = false end
		end
		return
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	-- Skeleton update
	if ESP_SETTINGS.Components.Skeleton.Enabled then
		local joints, connections

		if humanoid.RigType == Enum.HumanoidRigType.R15 then
			joints = R15_JOINTS
			connections = R15_CONNECTIONS
		else
			joints = R6_JOINTS
			connections = R6_CONNECTIONS
		end

		-- Cache joint objects
		local jointObjects = {}
		for name, jointName in pairs(joints) do
			jointObjects[name] = character:FindFirstChild(jointName)
		end

		for index, connection in ipairs(connections) do
			local jointA = jointObjects[connection[1]]
			local jointB = jointObjects[connection[2]]
			local lineKey = "line_"..index

			if jointA and jointB then
				local posA, onScreenA = Camera:WorldToViewportPoint(jointA.Position)
				local posB, onScreenB = Camera:WorldToViewportPoint(jointB.Position)

				local line = GetCachedDrawing("Line", lineKey, skeleton, {
					Color = GetPlayerColor(plr, "Skeleton"),
					Thickness = ESP_SETTINGS.Components.Skeleton.Thickness
				})

				if onScreenA and onScreenB and (not ESP_SETTINGS.Components.Skeleton.VisibleOnly or 
					(IsPartVisible(jointA, character) and IsPartVisible(jointB, character))) then
					line.From = Vector2.new(posA.X, posA.Y)
					line.To = Vector2.new(posB.X, posB.Y)
					line.Visible = true
				else
					line.Visible = false
				end
			elseif skeleton[lineKey] then
				skeleton[lineKey].Visible = false
			end
		end

		-- Head circle
		if ESP_SETTINGS.Components.Skeleton.HeadCircle.Enabled then
			local head = jointObjects.Head
			if head then
				local headPos, onScreen = Camera:WorldToViewportPoint(head.Position)
				local distance = (head.Position - Camera.CFrame.Position).Magnitude

				local headCircle = GetCachedDrawing("Circle", "headCircle", skeleton, {
					Color = GetPlayerColor(plr, "Skeleton"),
					Thickness = ESP_SETTINGS.Components.Skeleton.HeadCircle.Thickness,
					Filled = false
				})

				if ESP_SETTINGS.Components.Skeleton.HeadCircle.DynamicSize then
					local size = ESP_SETTINGS.Components.Skeleton.HeadCircle.BaseSize / (distance * 0.1)
					headCircle.Radius = math.max(size, ESP_SETTINGS.Components.Skeleton.HeadCircle.MinSize)
				else
					headCircle.Radius = 8
				end

				if onScreen and (not ESP_SETTINGS.Components.Skeleton.VisibleOnly or IsPartVisible(head, character)) then
					headCircle.Position = Vector2.new(headPos.X, headPos.Y)
					headCircle.Visible = true
				else
					headCircle.Visible = false
				end
			end
		else
			if skeleton.headCircle then
				skeleton.headCircle.Visible = false
			end
		end
	else
		ClearComponent(skeleton, "line_")
		if skeleton.headCircle then
			skeleton.headCircle.Visible = false
		end
	end

	-- Name and distance
	if ESP_SETTINGS.Components.Name.Enabled then
		local head = character:FindFirstChild("Head")
		if head then
			local headPos, onScreen = Camera:WorldToViewportPoint(head.Position)

			local nameText = GetCachedDrawing("Text", "nameText", skeleton, {
				Color = GetPlayerColor(plr, "Name"),
				Size = ESP_SETTINGS.Components.Name.Size,
				Outline = ESP_SETTINGS.Components.Name.Outline,
				OutlineColor = ESP_SETTINGS.Components.Name.OutlineColor,
				Center = true
			})

			local distanceText = ""
			if ESP_SETTINGS.Components.Name.ShowDistance then
				local distance = (head.Position - Camera.CFrame.Position).Magnitude
				distanceText = string.format(" [%d]", math.floor(distance))
			end

			nameText.Text = plr.Name .. distanceText

			if onScreen then
				nameText.Position = Vector2.new(
					headPos.X + ESP_SETTINGS.Components.Name.Offset.X,
					headPos.Y + ESP_SETTINGS.Components.Name.Offset.Y
				)
				nameText.Visible = true
			else
				nameText.Visible = false
			end
		end
	else
		if skeleton.nameText then
			skeleton.nameText.Visible = false
		end
	end

	-- Box ESP
	if ESP_SETTINGS.Components.Box.Enabled then
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if rootPart then
			local rootPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

			if onScreen and (not ESP_SETTINGS.Components.Box.VisibleOnly or IsPartVisible(rootPart, character)) then
				local torsoName = humanoid.RigType == Enum.HumanoidRigType.R15 and "UpperTorso" or "Torso"
				local torso = character:FindFirstChild(torsoName)
				local head = character:FindFirstChild("Head")

				if torso and head then
					local height = (head.Position - torso.Position).Magnitude * 2.5
					local width = math.max(head.Size.X, torso.Size.X) * 2
					local depth = width * 0.6

					local cf = rootPart.CFrame
					local size = Vector3.new(width, height, depth)

					-- Get all 8 corners of the 3D box
					local corners = {
						cf * CFrame.new(size.X/2, size.Y/2, size.Z/2),
						cf * CFrame.new(-size.X/2, size.Y/2, size.Z/2),
						cf * CFrame.new(-size.X/2, -size.Y/2, size.Z/2),
						cf * CFrame.new(size.X/2, -size.Y/2, size.Z/2),
						cf * CFrame.new(size.X/2, size.Y/2, -size.Z/2),
						cf * CFrame.new(-size.X/2, size.Y/2, -size.Z/2),
						cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2),
						cf * CFrame.new(size.X/2, -size.Y/2, -size.Z/2)
					}

					-- Convert to screen space
					local screenPoints = {}
					local allVisible = true
					for i, corner in ipairs(corners) do
						local screenPoint, onScreen = Camera:WorldToViewportPoint(corner.Position)
						screenPoints[i] = Vector2.new(screenPoint.X, screenPoint.Y)
						if not onScreen then allVisible = false end
					end

					if allVisible then
						-- Define edges
						local edges = {
							{1, 2}, {2, 3}, {3, 4}, {4, 1}, -- Front face
							{5, 6}, {6, 7}, {7, 8}, {8, 5}, -- Back face
							{1, 5}, {2, 6}, {3, 7}, {4, 8}  -- Connecting edges
						}

						-- Draw edges
						for i, edge in ipairs(edges) do
							local line = GetCachedDrawing("Line", "box3d_line_"..i, skeleton, {
								Color = GetPlayerColor(plr, "Box"),
								Thickness = ESP_SETTINGS.Components.Box.Thickness
							})
							line.From = screenPoints[edge[1]]
							line.To = screenPoints[edge[2]]
							line.Visible = true
						end
					end
				end
			end
		end
	else
		ClearComponent(skeleton, "box3d_line_")
	end
end

-- Player tracking
local function TrackPlayer(plr)
	if plr == LocalPlayer then return end

	local skeleton = {}
	Skeletons[plr] = skeleton

	local connection
	connection = RunService.Heartbeat:Connect(function()
		UpdateSkeleton(plr, skeleton)
	end)

	plr.AncestryChanged:Connect(function(_, parent)
		if not parent then
			connection:Disconnect()
			RemoveSkeleton(skeleton)
			Skeletons[plr] = nil
		end
	end)

	plr.CharacterRemoving:Connect(function()
		RemoveSkeleton(skeleton)
	end)
end

-- API
function ESP:ToggleMaster(state)
	ESP_SETTINGS.MasterSwitch = state
	if not state then
		for _, skeleton in pairs(Skeletons) do
			RemoveSkeleton(skeleton)
		end
	end
end

function ESP:ToggleSkeleton(state)
	ESP_SETTINGS.Components.Skeleton.Enabled = state
end

function ESP:ToggleNames(state)
	ESP_SETTINGS.Components.Name.Enabled = state
end

function ESP:ToggleBox(state)
	ESP_SETTINGS.Components.Box.Enabled = state
end

setmetatable(ESP, {
	__index = function(t, k)
		if k == "MasterEnabled" then
			return ESP_SETTINGS.MasterSwitch
		elseif k == "SkeletonEnabled" then
			return ESP_SETTINGS.Components.Skeleton.Enabled
		elseif k == "NamesEnabled" then
			return ESP_SETTINGS.Components.Name.Enabled
		elseif k == "BoxEnabled" then
			return ESP_SETTINGS.Components.Box.Enabled
		end
	end,
	__newindex = function(t, k, v)
		if k == "MasterEnabled" then
			ESP:ToggleMaster(v)
		elseif k == "SkeletonEnabled" then
			ESP:ToggleSkeleton(v)
		elseif k == "NamesEnabled" then
			ESP:ToggleNames(v)
		elseif k == "BoxEnabled" then
			ESP:ToggleBox(v)
		end
	end
})

-- Initialization
Players.PlayerAdded:Connect(TrackPlayer)
Players.PlayerRemoving:Connect(function(plr)
	RemoveSkeleton(Skeletons[plr])
	Skeletons[plr] = nil
end)

for _, plr in ipairs(Players:GetPlayers()) do
	if plr ~= LocalPlayer then
		TrackPlayer(plr)
	end
end

return ESP
