local ESP = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera

local ESP_SETTINGS = {
    Enabled = false,               -- Включен ли ESP
    Color = Color3.new(0, 1, 0),  -- Зеленый цвет
    Thickness = 2,                -- Толщина линий
    TeamCheck = true,             -- Проверка команд
    VisibleOnly = false,          -- Всегда показывать
    HeadCircle = true,            -- Показывать круг вокруг головы
    HeadCircleBaseRadius = 15,    -- Базовый радиус на близком расстоянии
    HeadCircleMinRadius = 3,      -- Минимальный радиус на дальнем расстоянии
    HeadCircleMaxDistance = 100,  -- Дистанция, после которой радиус не уменьшается
    HeadCircleThickness = 2       -- Толщина круга головы
}

local player = Players.LocalPlayer
local skeletons = {}

-- Создание новой линии
local function createLine()
    local line = Drawing.new("Line")
    line.Visible = false
    line.ZIndex = 10
    return line
end

-- Создание нового круга
local function createCircle()
    local circle = Drawing.new("Circle")
    circle.Visible = false
    circle.ZIndex = 10
    circle.Filled = false
    return circle
end

-- Удаление скелета
local function removeSkeleton(skeleton)
    if not skeleton then return end
    for _, drawing in pairs(skeleton) do
        if drawing and drawing.Remove then
            drawing:Remove()
        end
    end
end

-- Проверка видимости части
local function isPartVisible(part)
    if not part then return false end
    local cameraPos = camera.CFrame.Position
    local partPos = part.Position
    local ray = Ray.new(cameraPos, (partPos - cameraPos).Unit * 1000)
    local hit = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character})
    return hit == nil or hit:IsDescendantOf(part.Parent)
end

-- Обновление скелета игрока
local function updateSkeleton(plr, skeleton)
    if not ESP_SETTINGS.Enabled then
        for _, drawing in pairs(skeleton) do
            if drawing then drawing.Visible = false end
        end
        return
    end

    if not plr or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then
        for _, drawing in pairs(skeleton) do
            if drawing then drawing.Visible = false end
        end
        return
    end

    local character = plr.Character
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end

    local joints = {}
    local connections = {}

    -- Определяем соединения для R15 и R6
    if humanoid.RigType == Enum.HumanoidRigType.R15 then
        joints = {
            Head = character:FindFirstChild("Head"),
            UpperTorso = character:FindFirstChild("UpperTorso"),
            LowerTorso = character:FindFirstChild("LowerTorso"),
            LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
            LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
            LeftHand = character:FindFirstChild("LeftHand"),
            RightUpperArm = character:FindFirstChild("RightUpperArm"),
            RightLowerArm = character:FindFirstChild("RightLowerArm"),
            RightHand = character:FindFirstChild("RightHand"),
            LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
            LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
            RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
            RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
        }

        connections = {
            {"Head", "UpperTorso"},
            {"UpperTorso", "LowerTorso"},
            {"UpperTorso", "LeftUpperArm"},
            {"LeftUpperArm", "LeftLowerArm"},
            {"LeftLowerArm", "LeftHand"},
            {"UpperTorso", "RightUpperArm"},
            {"RightUpperArm", "RightLowerArm"},
            {"RightLowerArm", "RightHand"},
            {"LowerTorso", "LeftUpperLeg"},
            {"LeftUpperLeg", "LeftLowerLeg"},
            {"LowerTorso", "RightUpperLeg"},
            {"RightUpperLeg", "RightLowerLeg"},
        }
    else
        joints = {
            Head = character:FindFirstChild("Head"),
            Torso = character:FindFirstChild("Torso"),
            LeftArm = character:FindFirstChild("Left Arm"),
            RightArm = character:FindFirstChild("Right Arm"),
            LeftLeg = character:FindFirstChild("Left Leg"),
            RightLeg = character:FindFirstChild("Right Leg"),
        }

        connections = {
            {"Head", "Torso"},
            {"Torso", "LeftArm"},
            {"Torso", "RightArm"},
            {"Torso", "LeftLeg"},
            {"Torso", "RightLeg"},
        }
    end

    -- Обработка соединений костей
    for index, connection in ipairs(connections) do
        local jointA = joints[connection[1]]
        local jointB = joints[connection[2]]

        if jointA and jointB then
            local posA, onScreenA = camera:WorldToViewportPoint(jointA.Position)
            local posB, onScreenB = camera:WorldToViewportPoint(jointB.Position)

            local line = skeleton["line_"..index] or createLine()
            skeleton["line_"..index] = line

            line.Color = ESP_SETTINGS.Color
            line.Thickness = ESP_SETTINGS.Thickness

            if onScreenA and onScreenB and (not ESP_SETTINGS.VisibleOnly or (isPartVisible(jointA) and isPartVisible(jointB))) then
                line.From = Vector2.new(posA.X, posA.Y)
                line.To = Vector2.new(posB.X, posB.Y)
                line.Visible = true
            else
                line.Visible = false
            end
        elseif skeleton["line_"..index] then
            skeleton["line_"..index].Visible = false
        end
    end

    -- Обработка круга вокруг головы с динамическим радиусом
    if ESP_SETTINGS.HeadCircle then
        local head = joints.Head
        if head then
            local headPos, onScreen = camera:WorldToViewportPoint(head.Position)
            
            -- Рассчитываем динамический радиус на основе расстояния
            local distance = (head.Position - camera.CFrame.Position).Magnitude
            local distanceFactor = math.clamp(distance / ESP_SETTINGS.HeadCircleMaxDistance, 0, 1)
            local dynamicRadius = ESP_SETTINGS.HeadCircleBaseRadius * (1 - distanceFactor) + 
                                ESP_SETTINGS.HeadCircleMinRadius * distanceFactor
            
            local headCircle = skeleton.headCircle or createCircle()
            skeleton.headCircle = headCircle
            
            headCircle.Color = ESP_SETTINGS.Color
            headCircle.Thickness = ESP_SETTINGS.HeadCircleThickness
            headCircle.Radius = dynamicRadius
            
            if onScreen and (not ESP_SETTINGS.VisibleOnly or isPartVisible(head)) then
                headCircle.Position = Vector2.new(headPos.X, headPos.Y)
                headCircle.Visible = true
            else
                headCircle.Visible = false
            end
        elseif skeleton.headCircle then
            skeleton.headCircle.Visible = false
        end
    end
end

-- Трекинг игрока
local function trackPlayer(plr)
    if plr == player then return end
    
    local skeleton = {}
    skeletons[plr] = skeleton

    local connection
    connection = RunService.Heartbeat:Connect(function()
        updateSkeleton(plr, skeleton)
    end)

    -- Очистка при удалении игрока
    plr.AncestryChanged:Connect(function(_, parent)
        if not parent then
            connection:Disconnect()
            removeSkeleton(skeleton)
            skeletons[plr] = nil
        end
    end)
end

-- Включение/выключение ESP
function ESP:Toggle(state)
    ESP_SETTINGS.Enabled = state
    for plr, skeleton in pairs(skeletons) do
        updateSkeleton(plr, skeleton)
    end
end

-- Включение/выключение круга головы
function ESP:ToggleHeadCircle(state)
    ESP_SETTINGS.HeadCircle = state
    for plr, skeleton in pairs(skeletons) do
        updateSkeleton(plr, skeleton)
    end
end

-- Инициализация
Players.PlayerAdded:Connect(trackPlayer)
Players.PlayerRemoving:Connect(function(plr)
    removeSkeleton(skeletons[plr])
    skeletons[plr] = nil
end)

for _, plr in ipairs(Players:GetPlayers()) do
    trackPlayer(plr)
end

-- Добавляем метатаблицу для ESP.Enabled
setmetatable(ESP, {
    __index = function(t, k)
        if k == "Enabled" then
            return ESP_SETTINGS.Enabled
        end
    end,
    __newindex = function(t, k, v)
        if k == "Enabled" then
            ESP_SETTINGS.Enabled = v
            for plr, skeleton in pairs(skeletons) do
                updateSkeleton(plr, skeleton)
            end
        end
    end
})

return ESP
