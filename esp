local ESP = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera

local ESP_SETTINGS = {
	MasterSwitch = false,
	Components = {
		Skeleton = {
			Enabled = false,
			Color = Color3.new(1, 0, 0),
			Thickness = 2,
			TeamCheck = false,
			VisibleOnly = false,
			HeadCircle = true,
			HeadCircleBaseRadius = 15,  -- Базовый радиус на близком расстоянии
			HeadCircleMinRadius = 3,    -- Минимальный радиус на дальнем расстоянии
			HeadCircleMaxDistance = 15, -- Дистанция, после которой радиус не уменьшается
			HeadCircleThickness = 2
		},
		Name = {
			Enabled = false,
			Color = Color3.new(1, 1, 1),
			ShowDistance = true,
			Size = 14,
			Outline = true,
			OutlineColor = Color3.new(0, 0, 0),
			Offset = Vector2.new(0, -30)
		}
	}
}

local player = Players.LocalPlayer
local skeletons = {}

-- Создание Drawing объектов
local function createLine()
	local line = Drawing.new("Line")
	line.Visible = false
	line.ZIndex = 10
	return line
end

local function createCircle()
	local circle = Drawing.new("Circle")
	circle.Visible = false
	circle.ZIndex = 10
	circle.Filled = false
	return circle
end

local function createText()
	local text = Drawing.new("Text")
	text.Visible = false
	text.ZIndex = 10
	text.Center = true
	return text
end

-- Удаление скелета
local function removeSkeleton(skeleton)
	if not skeleton then return end
	for _, drawing in pairs(skeleton) do
		if drawing and drawing.Remove then
			drawing:Remove()
		end
	end
end

-- Проверка видимости
local function isPartVisible(part)
	if not part then return false end
	local cameraPos = camera.CFrame.Position
	local partPos = part.Position
	local ray = Ray.new(cameraPos, (partPos - cameraPos).Unit * 1000)
	local hit = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character})
	return hit == nil or hit:IsDescendantOf(part.Parent)
end

-- Получение цвета для игрока
local function getPlayerColor(plr, forSkeleton)
	local settings = ESP_SETTINGS.Components[forSkeleton and "Skeleton" or "Name"]
	if forSkeleton and settings.TeamCheck and plr.Team then
		return plr.TeamColor.Color
	end
	return settings.Color
end

-- Обновление ESP
local function updateSkeleton(plr, skeleton)
	-- Главный переключатель выключен - скрываем всё
	if not ESP_SETTINGS.MasterSwitch then
		for _, drawing in pairs(skeleton) do
			if drawing then drawing.Visible = false end
		end
		return
	end

	if not plr or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then
		for _, drawing in pairs(skeleton) do
			if drawing then drawing.Visible = false end
		end
		return
	end

	local character = plr.Character
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then return end

	-- Обновление скелета
	if ESP_SETTINGS.Components.Skeleton.Enabled then
		local joints = {}
		local connections = {}

		if humanoid.RigType == Enum.HumanoidRigType.R15 then
			joints = {
				Head = character:FindFirstChild("Head"),
				UpperTorso = character:FindFirstChild("UpperTorso"),
				LowerTorso = character:FindFirstChild("LowerTorso"),
				LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
				LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
				LeftHand = character:FindFirstChild("LeftHand"),
				RightUpperArm = character:FindFirstChild("RightUpperArm"),
				RightLowerArm = character:FindFirstChild("RightLowerArm"),
				RightHand = character:FindFirstChild("RightHand"),
				LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
				LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
				RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
				RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
			}

			connections = {
				{"Head", "UpperTorso"},
				{"UpperTorso", "LowerTorso"},
				{"UpperTorso", "LeftUpperArm"},
				{"LeftUpperArm", "LeftLowerArm"},
				{"LeftLowerArm", "LeftHand"},
				{"UpperTorso", "RightUpperArm"},
				{"RightUpperArm", "RightLowerArm"},
				{"RightLowerArm", "RightHand"},
				{"LowerTorso", "LeftUpperLeg"},
				{"LeftUpperLeg", "LeftLowerLeg"},
				{"LowerTorso", "RightUpperLeg"},
				{"RightUpperLeg", "RightLowerLeg"},
			}
		else
			joints = {
				Head = character:FindFirstChild("Head"),
				Torso = character:FindFirstChild("Torso"),
				LeftArm = character:FindFirstChild("Left Arm"),
				RightArm = character:FindFirstChild("Right Arm"),
				LeftLeg = character:FindFirstChild("Left Leg"),
				RightLeg = character:FindFirstChild("Right Leg"),
			}

			connections = {
				{"Head", "Torso"},
				{"Torso", "LeftArm"},
				{"Torso", "RightArm"},
				{"Torso", "LeftLeg"},
				{"Torso", "RightLeg"},
			}
		end

		for index, connection in ipairs(connections) do
			local jointA = joints[connection[1]]
			local jointB = joints[connection[2]]

			if jointA and jointB then
				local posA, onScreenA = camera:WorldToViewportPoint(jointA.Position)
				local posB, onScreenB = camera:WorldToViewportPoint(jointB.Position)

				local line = skeleton["line_"..index] or createLine()
				skeleton["line_"..index] = line

				line.Color = getPlayerColor(plr, true)
				line.Thickness = ESP_SETTINGS.Components.Skeleton.Thickness

				if onScreenA and onScreenB and (not ESP_SETTINGS.Components.Skeleton.VisibleOnly or (isPartVisible(jointA) and isPartVisible(jointB))) then
					line.From = Vector2.new(posA.X, posA.Y)
					line.To = Vector2.new(posB.X, posB.Y)
					line.Visible = true
				else
					line.Visible = false
				end
			elseif skeleton["line_"..index] then
				skeleton["line_"..index].Visible = false
			end
		end

		if ESP_SETTINGS.Components.Skeleton.HeadCircle then
			local head = joints.Head
			if head then
				local headPos, onScreen = camera:WorldToViewportPoint(head.Position)

				local headCircle = skeleton.headCircle or createCircle()
				skeleton.headCircle = headCircle

				headCircle.Color = getPlayerColor(plr, true)
				headCircle.Thickness = ESP_SETTINGS.Components.Skeleton.HeadCircleThickness

				-- Рассчитываем динамический радиус
				local radius = ESP_SETTINGS.Components.Skeleton.HeadCircleBaseRadius
				if ESP_SETTINGS.Components.Skeleton.HeadCircleDynamicScaling then
					local distance = (head.Position - camera.CFrame.Position).Magnitude
					local distanceFactor = math.clamp(distance / ESP_SETTINGS.Components.Skeleton.HeadCircleMaxDistance, 0, 1)
					radius = ESP_SETTINGS.Components.Skeleton.HeadCircleBaseRadius * (1 - distanceFactor) + 
						ESP_SETTINGS.Components.Skeleton.HeadCircleMinRadius * distanceFactor
				end

				headCircle.Radius = radius

				if onScreen and (not ESP_SETTINGS.Components.Skeleton.VisibleOnly or isPartVisible(head)) then
					headCircle.Position = Vector2.new(headPos.X, headPos.Y)
					headCircle.Visible = true
				else
					headCircle.Visible = false
				end
			elseif skeleton.headCircle then
				skeleton.headCircle.Visible = false
			end
		end
	else
		-- Скрываем скелет если он отключен
		for k, drawing in pairs(skeleton) do
			if type(k) == "string" and (k:find("line_") or k == "headCircle") then
				drawing.Visible = false
			end
		end
	end

	-- Обновление имени и дистанции
	if ESP_SETTINGS.Components.Name.Enabled then
		local head = character:FindFirstChild("Head")
		if head then
			local headPos, onScreen = camera:WorldToViewportPoint(head.Position)

			local nameText = skeleton.nameText or createText()
			skeleton.nameText = nameText

			nameText.Color = getPlayerColor(plr, false)
			nameText.Size = ESP_SETTINGS.Components.Name.Size
			nameText.Outline = ESP_SETTINGS.Components.Name.Outline
			nameText.OutlineColor = ESP_SETTINGS.Components.Name.OutlineColor

			local distanceText = ""
			if ESP_SETTINGS.Components.Name.ShowDistance then
				local distance = (head.Position - camera.CFrame.Position).Magnitude
				distanceText = string.format(" [%d]", math.floor(distance))
			end

			nameText.Text = plr.Name .. distanceText

			if onScreen then
				nameText.Position = Vector2.new(
					headPos.X + ESP_SETTINGS.Components.Name.Offset.X,
					headPos.Y + ESP_SETTINGS.Components.Name.Offset.Y
				)
				nameText.Visible = true
			else
				nameText.Visible = false
			end
		elseif skeleton.nameText then
			skeleton.nameText.Visible = false
		end
	elseif skeleton.nameText then
		skeleton.nameText.Visible = false
	end
end

-- Трекинг игрока
local function trackPlayer(plr)
	if plr == player then return end

	local skeleton = {}
	skeletons[plr] = skeleton

	local connection
	connection = RunService.Heartbeat:Connect(function()
		updateSkeleton(plr, skeleton)
	end)

	plr.AncestryChanged:Connect(function(_, parent)
		if not parent then
			connection:Disconnect()
			removeSkeleton(skeleton)
			skeletons[plr] = nil
		end
	end)
end

-- API функции
function ESP:ToggleMaster(state)
	ESP_SETTINGS.MasterSwitch = state
	self:UpdateAll()
end


function ESP:ToggleSkeleton(state)
	ESP_SETTINGS.Components.Skeleton.Enabled = state
	self:UpdateAll()
end

function ESP:ToggleNames(state)
	ESP_SETTINGS.Components.Name.Enabled = state
	self:UpdateAll()
end

function ESP:SetSkeletonColor(color)
	ESP_SETTINGS.Components.Skeleton.Color = color
	self:UpdateAll()
end

function ESP:SetNameColor(color)
	ESP_SETTINGS.Components.Name.Color = color
	for plr, skeleton in pairs(skeletons) do
		updateSkeleton(plr, skeleton)
	end
end
function ESP:UpdateAll()
	for plr, skeleton in pairs(skeletons) do
		updateSkeleton(plr, skeleton)
	end
end

-- Инициализация
Players.PlayerAdded:Connect(trackPlayer)
Players.PlayerRemoving:Connect(function(plr)
	removeSkeleton(skeletons[plr])
	skeletons[plr] = nil
end)

for _, plr in ipairs(Players:GetPlayers()) do
	trackPlayer(plr)
end

-- Метатаблица для удобного доступа
setmetatable(ESP, {
	__index = function(t, k)
		if k == "Enabled" then
			return ESP_SETTINGS.MasterSwitch
		elseif k == "SkeletonEnabled" then
			return ESP_SETTINGS.Components.Skeleton.Enabled
		elseif k == "NamesEnabled" then
			return ESP_SETTINGS.Components.Name.Enabled
		end
	end,
	__newindex = function(t, k, v)
		if k == "Enabled" then
			ESP:ToggleMaster(v)
		elseif k == "SkeletonEnabled" then
			ESP:ToggleSkeleton(v)
		elseif k == "NamesEnabled" then
			ESP:ToggleNames(v)
		end
	end
})

return ESP
