local ESP = {
    Settings = {
        BoxOutlineColor = Color3.new(0, 0, 0),
        BoxColor = Color3.new(1, 1, 1),
        NameColor = Color3.new(1, 1, 1),
        HealthOutlineColor = Color3.new(0, 0, 0),
        HealthHighColor = Color3.new(0, 1, 0),
        HealthLowColor = Color3.new(1, 0, 0),
        CharSize = Vector2.new(4, 6),
        Teamcheck = false,
        WallCheck = false,
        Enabled = false,
        ShowBox = false,
        BoxType = "2D",
        ShowName = false,
        ShowHealth = false,
        ShowDistance = false,
        ShowSkeletons = false,
        ShowTracer = false,
        TracerColor = Color3.new(1, 1, 1), 
        TracerThickness = 2,
        SkeletonsColor = Color3.new(1, 1, 1),
        TracerPosition = "Bottom",
    },
    
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    camera = workspace.CurrentCamera,
    cache = {}
}

-- Инициализация
function ESP:Init()
    for _, player in ipairs(self.Players:GetPlayers()) do
        if player ~= self.Players.LocalPlayer then
            self:CreateEsp(player)
        end
    end
    
    self.Players.PlayerAdded:Connect(function(player)
        if player ~= self.Players.LocalPlayer then
            self:CreateEsp(player)
        end
    end)
    
    self.Players.PlayerRemoving:Connect(function(player)
        self:RemoveEsp(player)
    end)
    
    self.RunService.RenderStepped:Connect(function()
        for player, _ in pairs(self.cache) do
            self:UpdateEsp(player)
        end
    end)
end

-- Создание элементов Drawing
function ESP:CreateLine()
    local line = Drawing.new("Line")
    line.Visible = false
    line.ZIndex = 10
    return line
end

function ESP:CreateCircle()
    local circle = Drawing.new("Circle")
    circle.Visible = false
    circle.ZIndex = 10
    circle.Filled = false
    return circle
end

-- Удаление скелета
function ESP:RemoveSkeleton(skeleton)
    if not skeleton then return end
    for _, drawing in pairs(skeleton) do
        if drawing and drawing.Remove then
            drawing:Remove()
        end
    end
end

-- Проверка видимости
function ESP:IsPartVisible(part)
    if not part then return false end
    local cameraPos = self.camera.CFrame.Position
    local partPos = part.Position
    local ray = Ray.new(cameraPos, (partPos - cameraPos).Unit * 1000)
    local hit = workspace:FindPartOnRayWithIgnoreList(ray, {self.player.Character})
    return hit == nil or hit:IsDescendantOf(part.Parent)
end

-- Обновление скелета игрока
function ESP:UpdateSkeleton(plr, skeleton)
   if not ESP_SETTINGS.Enabled then
        for _, drawing in pairs(skeleton) do
            if drawing then drawing.Visible = false end
        end
        return
    end

    if not plr or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then
        for _, drawing in pairs(skeleton) do
            if drawing then drawing.Visible = false end
        end
        return
    end

    local character = plr.Character
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end

    local joints = {}
    local connections = {}

    -- Определяем соединения для R15 и R6
    if humanoid.RigType == Enum.HumanoidRigType.R15 then
        joints = {
            Head = character:FindFirstChild("Head"),
            UpperTorso = character:FindFirstChild("UpperTorso"),
            LowerTorso = character:FindFirstChild("LowerTorso"),
            LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
            LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
            LeftHand = character:FindFirstChild("LeftHand"),
            RightUpperArm = character:FindFirstChild("RightUpperArm"),
            RightLowerArm = character:FindFirstChild("RightLowerArm"),
            RightHand = character:FindFirstChild("RightHand"),
            LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
            LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
            RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
            RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
        }

        connections = {
            {"Head", "UpperTorso"},
            {"UpperTorso", "LowerTorso"},
            {"UpperTorso", "LeftUpperArm"},
            {"LeftUpperArm", "LeftLowerArm"},
            {"LeftLowerArm", "LeftHand"},
            {"UpperTorso", "RightUpperArm"},
            {"RightUpperArm", "RightLowerArm"},
            {"RightLowerArm", "RightHand"},
            {"LowerTorso", "LeftUpperLeg"},
            {"LeftUpperLeg", "LeftLowerLeg"},
            {"LowerTorso", "RightUpperLeg"},
            {"RightUpperLeg", "RightLowerLeg"},
        }
    else
        joints = {
            Head = character:FindFirstChild("Head"),
            Torso = character:FindFirstChild("Torso"),
            LeftArm = character:FindFirstChild("Left Arm"),
            RightArm = character:FindFirstChild("Right Arm"),
            LeftLeg = character:FindFirstChild("Left Leg"),
            RightLeg = character:FindFirstChild("Right Leg"),
        }

        connections = {
            {"Head", "Torso"},
            {"Torso", "LeftArm"},
            {"Torso", "RightArm"},
            {"Torso", "LeftLeg"},
            {"Torso", "RightLeg"},
        }
    end

    -- Обработка соединений костей
    for index, connection in ipairs(connections) do
        local jointA = joints[connection[1]]
        local jointB = joints[connection[2]]

        if jointA and jointB then
            local posA, onScreenA = camera:WorldToViewportPoint(jointA.Position)
            local posB, onScreenB = camera:WorldToViewportPoint(jointB.Position)

            local line = skeleton["line_"..index] or createLine()
            skeleton["line_"..index] = line

            line.Color = ESP_SETTINGS.Color
            line.Thickness = ESP_SETTINGS.Thickness

            if onScreenA and onScreenB and (not ESP_SETTINGS.VisibleOnly or (isPartVisible(jointA) and isPartVisible(jointB))) then
                line.From = Vector2.new(posA.X, posA.Y)
                line.To = Vector2.new(posB.X, posB.Y)
                line.Visible = true
            else
                line.Visible = false
            end
        elseif skeleton["line_"..index] then
            skeleton["line_"..index].Visible = false
        end
    end

    -- Обработка круга вокруг головы с динамическим радиусом
    if ESP_SETTINGS.HeadCircle then
        local head = joints.Head
        if head then
            local headPos, onScreen = camera:WorldToViewportPoint(head.Position)
            
            -- Рассчитываем динамический радиус на основе расстояния
            local distance = (head.Position - camera.CFrame.Position).Magnitude
            local distanceFactor = math.clamp(distance / ESP_SETTINGS.HeadCircleMaxDistance, 0, 1)
            local dynamicRadius = ESP_SETTINGS.HeadCircleBaseRadius * (1 - distanceFactor) + 
                                ESP_SETTINGS.HeadCircleMinRadius * distanceFactor
            
            local headCircle = skeleton.headCircle or createCircle()
            skeleton.headCircle = headCircle
            
            headCircle.Color = ESP_SETTINGS.Color
            headCircle.Thickness = ESP_SETTINGS.HeadCircleThickness
            headCircle.Radius = dynamicRadius
            
            if onScreen and (not ESP_SETTINGS.VisibleOnly or isPartVisible(head)) then
                headCircle.Position = Vector2.new(headPos.X, headPos.Y)
                headCircle.Visible = true
            else
                headCircle.Visible = false
            end
        elseif skeleton.headCircle then
            skeleton.headCircle.Visible = false
        end
    end
end

-- Трекинг игрока
function ESP:TrackPlayer(plr)
    if plr == self.player then return end
    
    local skeleton = {}
    self.skeletons[plr] = skeleton

    local connection
    connection = self.RunService.Heartbeat:Connect(function()
        self:UpdateSkeleton(plr, skeleton)
    end)

    plr.AncestryChanged:Connect(function(_, parent)
        if not parent then
            connection:Disconnect()
            self:RemoveSkeleton(skeleton)
            self.skeletons[plr] = nil
        end
    end)
end

-- Управление ESP
function ESP:Toggle(state)
    self.Settings.Enabled = state
    -- Принудительное обновление всех ESP
    for player, esp in pairs(self.cache) do
        self:UpdateEsp(player)
    end
end

function ESP:UpdateAll()
    for player, esp in pairs(self.cache) do
        self:UpdateEsp(player)
    end
end

function ESP:ToggleHeadCircle(state)
    self.ESP_SETTINGS.HeadCircle = state
    for plr, skeleton in pairs(self.skeletons) do
        self:UpdateSkeleton(plr, skeleton)
    end
end

ESP:Init()
return ESP
